# 해보자!

## 토큰 관련 Best Practice 공부하기
- [x] JWT 토큰이 de facto standard가 된 이유? 다른 토큰은 안 쓰나?
- [x] 토큰과 다른 인증방식의 장단점, 다른 걸 쓰는게 적절한 경우는 없는지 알아보기
- [x] JWT 사용시 주의점 알아보기
- [x] Java/Spring에서 JWT를 쓸 때의 Best Practice 알아보기
  - [x] 암호화는 그냥 SHA256 쓰면 되나?
  - [x] 페이로드는 암호화되는게 아니다!! 절대 민감한 정보를 넣으면 안 된다. 그럼 뭘 넣어야하나? 토큰에 PK를 노출시켜도 되나?
  - [x] 토큰 유효기간은 어떻게 설정?
  - [ ] OAuth가 뭔데? 리프레시 토큰은 또 뭔데?
- - -
1. 세션은 서버에서 세션 정보를 기억하고 있어야 한다. 즉, stateful하다
  - 서버를 horizontal scaling(scale out)할 때, 세션 정보를 모든 서버가 공유해야함. session storage 필요
  - -> 성능 이슈 뿐만 아니라, 구조가 복잡해짐(error-prone!)
2. JWT를 사용하면 stateless한 서버 아키텍쳐를 구성할 수 있다.
  - 분산 서버 환경이나 MSA 구조에 어울린다고 함
3. 왜 JWT? 다른 토큰도 있는데?
  - JSON 기반이라 웹 프론트엔드나 모바일 클라이언트와의 연동이 쉬움
  - `Base64(Header).Base64(Payload).Base64(Signature)`
  - stateless 구조의 이점은 다른 토큰들과 동일하지만, 이미 JWT가 광범위한 생태계를 구축해뒀을 뿐. 즉, 일종의 선점효과
4. 주의사항
  - **절대로** 페이로드에 민감한 정보를 담지 말아야 한다. 페이로드는 암호화가 아니라 그냥 Base64 인코딩된다
  - 헤더의 알고리즘을 none으로 두지 말아야 한다!!
  - 모놀리틱 서버라면 HS256같은 대칭키 알고리즘을 사용해도 되지만, MSA 구조라면 RS256같은 비대칭키 알고리즘을 사용해야 한다고 함
  - 엑세스 토큰의 유효기간은 가급적 짧게 설정하고, 리프레시 토큰을 통해 엑세스 토큰을 재발급받도록 하는 구조가 좋다고 함. OAuth랑 같이 공부해보기
- [x] TODO: 토큰을 통해 Auto Increment인 ID를 유추할 수 없도록 UUID 적용해보기

## 테스트 코드 작성하기
- [ ] JUnit 프레임워크 사용법 훑어보기 (당장 필요한 내용 위주로)
- [ ] 테스트 코드 작성시 유의사항 알아보기
- [ ] 테스트 코드 작성
  - [ ] 통합 테스트
  - [ ] 단위 테스트

## 커스텀 어노테이션으로 상품명 검증 수행하기
- [ ] 어노테이션 인터페이스 사용법, 커스텀 어노테이션 만드는 방법 찾아보기
- [ ] `@Valid` 어노테이션의 검증 프로세스 알아보기
- [ ] 커스텀 어노테이션을 `@Valid`의 검증 프로세스에 적용하는 방법 알아보기
- [ ] 커스텀 어노테이션 활용시 파일명, 코드 구조의 Best Practice 알아보기
- [ ] 적용

## RFC 문서 읽어보기
- [ ] HTTP 프로토콜 관련 문서들 원문으로 읽어보기
  - [ ] RFC 2616 - HTTP/1.1 (구버전)
  - [ ] RFC 7230 - HTTP/1.1 : Message Syntax and Routing
  - [ ] RFC 7231 - HTTP/1.1 : Semantics and Content
  - [ ] RFC 7232 - HTTP/1.1 : Conditional Requests
  - [ ] RFC 7233 - HTTP/1.1 : Range Requests 
  - [ ] RFC 7234 - HTTP/1.1 : Caching 
  - [ ] RFC 7235 - HTTP/1.1 : Authentication
