## step3 - 데이터베이스 적용

### 1. `JdbcTemplate`, `SimpleJdbcInsert`, `JdbcClient` 중 어떤 걸 선택할까?

#### 📌 선택 기준: **기존 코드 일관성 + 반환되는 엔티티가 PK를 포함해야 하는지 여부**

| 항목            | JdbcTemplate          | SimpleJdbcInsert      | JdbcClient                   |
|---------------|-----------------------|-----------------------|------------------------------|
| **SQL 작성 방식** | 직접 SQL 작성             | `INSERT`만 SQL 자동 생성   | 직접 SQL 작성 + 함수형 람다 스타일       |
| **코드 길이/가독성** | 유연하지만 boilerplate 길어짐 | `INSERT` 코드 짧고 간단     | 간결한 람다 기반 API                |
| **PK 반환**     | `KeyHolder` 필요        | 기본적으로 자동 키 반환 지원      | 제한적 지원 (드라이버와 상황에 따라 다름)     |
| **쿼리 매핑**     | RowMapper 등 다양한 매핑 방식 | 내부적으로 JdbcTemplate 이용 | 람다 스타일 콜백으로 간단하게 매핑 가능       |
| **트랜잭션 연동**   | 스프링 트랜잭션과 자연스럽게 연동됨   | 동일하게 연동됨              | 동일하게 연동됨                     |
| **복잡한 쿼리**    | 매우 자유로움               | INSERT 전용 도구          | 자유롭지만 JdbcTemplate만큼 풍부하진 않음 |

#### 🔍 선택 이유

* **현재 목표: `save()` 이후에 엔티티가 생성된 PK 값을 반드시 포함해야 함**
* `JdbcClient`는 아직 자동 생성 키 반환이 제한적이므로 제외
* **`SimpleJdbcInsert`는 오직 INSERT에만 특화되어 있어, 다른 DML과 함께 쓰기엔 코드 일관성이 무너짐**
* 따라서 복잡한 쿼리와 함께 사용할 수 있는 **JdbcTemplate을 선택**함

#### 💡 트레이드오프

* JdbcTemplate은 유연하고 강력하지만, SQL을 직접 작성해야 하므로 boilerplate가 길어질 수 있음
* 단일 책임 원칙(SRP)이나 역할 분리 원칙을 지키지 않으면, 쿼리 작성과 비즈니스 로직이 얽히기 쉬움 → 주의 필요

### 2. Insert 작업 이후 자동 생성된 PK는 어떻게 안전하게 가져올 수 있을까?

#### 📌 "왜" 중심의 설계 이유 설명

| 질문                                                | 이유                                                                                                   |
|---------------------------------------------------|------------------------------------------------------------------------------------------------------|
| **왜 PK 값을 바로 알아야 하나?**                            | → 저장 직후 객체를 클라이언트에 응답하거나, 연관 테이블 삽입 등에 사용하기 위해<br>→ insert 후에 바로 해당 엔티티를 식별할 수 있어야 하기 때문             |
| **왜 `KeyHolder`를 사용하나?**                          | → `JdbcTemplate.update()`는 영향받은 행의 개수만 반환<br>→ `KeyHolder`를 사용하면 DB가 생성한 키 값을 자바 코드에서 받을 수 있음        |
| **왜 `Statement.RETURN_GENERATED_KEYS` 옵션이 필요하나?** | → 이 옵션 없으면 DB는 자동 생성된 키 값을 반환하지 않음<br>→ 반드시 명시해야 KeyHolder가 값을 받을 수 있음                               |
| **왜 DB/드라이버 지원 여부를 확인해야 하나?**                     | → 모든 DB가 자동 키 반환을 동일하게 지원하지 않음<br>→ 예: MySQL은 기본적으로 지원하지만, 일부 DB는 `SELECT LAST_INSERT_ID()` 같은 방식 필요 |
| **왜 키가 null인 경우에 예외 처리를 해야 하나?**                  | → 실제로 키 반환에 실패하는 경우도 있음<br>→ 이런 경우 null 키가 사용되면 시스템 전체 안정성이 무너질 수 있음<br>→ 반드시 예외 던져서 빠르게 감지해야 함      |

#### 💡 트레이드오프

* `KeyHolder` 방식은 깔끔하긴 하지만, DB마다 드라이버 지원 상태가 달라서 **이식성**이 떨어질 수 있음
* 특히 MySQL, PostgreSQL, H2는 잘 동작하지만, Oracle 등에서는 설정에 따라 다를 수 있음

> 현재는 H2 기반으로 처리하기 때문에 적합